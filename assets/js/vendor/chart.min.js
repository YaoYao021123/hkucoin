// Simple Chart.js fallback for basic functionality
window.Chart = function(ctx, config) {
    try {
        const canvas = ctx;
        const context = canvas.getContext('2d');
        const type = config.type;
        const data = config.data;
        const options = config.options || {};

        // Clear canvas
        context.clearRect(0, 0, canvas.width, canvas.height);

        if (type === 'line') {
            drawLineChart(context, data, options, canvas.width, canvas.height);
        } else if (type === 'doughnut') {
            drawDoughnutChart(context, data, options, canvas.width, canvas.height);
        }

        console.log('Chart rendered with fallback method');
    } catch (error) {
        console.error('Fallback chart error:', error);
    }
};

function drawLineChart(ctx, data, options, width, height) {
    const datasets = data.datasets;
    const labels = data.labels;
    const padding = 40;

    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;

    // Draw axes
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, height - padding);
    ctx.lineTo(width - padding, height - padding);
    ctx.stroke();

    // Draw data lines
    datasets.forEach(dataset => {
        const points = dataset.data;
        ctx.strokeStyle = dataset.borderColor || '#6559F9';
        ctx.lineWidth = dataset.borderWidth || 2;
        ctx.beginPath();

        points.forEach((value, index) => {
            const x = padding + (index / (points.length - 1)) * (width - 2 * padding);
            const y = height - padding - (value / 120) * (height - 2 * padding); // Normalize to 0-120 range

            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });

        ctx.stroke();
    });
}

function drawDoughnutChart(ctx, data, options, width, height) {
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 3;
    const cutout = options.cutout || '50%';
    const innerRadius = radius * (parseInt(cutout) / 100);

    const datasets = data.datasets;
    const values = datasets[0].data;
    const colors = datasets[0].backgroundColor;
    const total = values.reduce((a, b) => a + b, 0);

    let currentAngle = -Math.PI / 2;

    values.forEach((value, index) => {
        const sliceAngle = (value / total) * 2 * Math.PI;

        // Draw slice
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
        ctx.arc(centerX, centerY, innerRadius, currentAngle + sliceAngle, currentAngle, true);
        ctx.closePath();
        ctx.fillStyle = colors[index] || '#6559F9';
        ctx.fill();

        currentAngle += sliceAngle;
    });
}